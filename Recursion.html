<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Importance and Uses of Recursion in C++</title>
</head>
<body>
    
    <header>
        <nav>
            <ul class="nav-list">
                <li><a href="index.html" class="home-btn">Home</a></li>
                <!-- عناصر قائمة أخرى هنا -->
            </ul>
        </nav>
    </header>
    
    <section>
        <h2>Importance and Uses of Recursion in C++</h2>
        
        <p>In **C++**, **Recursion** is a technique where a function calls itself to solve smaller instances of the same problem. It is particularly useful in scenarios where problems can be broken down into smaller subproblems of the same type, such as tree traversal, solving mathematical sequences, and divide-and-conquer algorithms.</p>
        
        <h3>Importance of Recursion in C++:</h3>
        
        <ul>
            <li><strong>Simplifies Complex Problems:</strong> Recursion can make code cleaner and easier to understand, especially for problems that have a recursive nature like traversing trees or solving puzzles.</li>
            <li><strong>Natural Representation:</strong> Many algorithms (like the Fibonacci series or factorial) are naturally recursive, and using recursion represents the problem more directly.</li>
            <li><strong>Divide and Conquer:</strong> Recursion is fundamental to divide-and-conquer algorithms such as merge sort and quicksort.</li>
        </ul>

        <h3>How to Write a Recursive Function:</h3>
        
        <p>A recursive function typically consists of two parts: the **base case**, which stops the recursion, and the **recursive case**, where the function calls itself to solve a smaller part of the problem.</p>
        
        <h4>Syntax:</h4>
        
        <pre>
returnType functionName(parameters) {
    if (base_case_condition) {
        return base_case_value;
    } else {
        // Recursive case: Function calls itself with modified parameters
        return recursive_case_value;
    }
}
        </pre>

        <h4>Examples:</h4>
        
        <h5>Example 1: Factorial of a number</h5>
        <pre>
#include &lt;iostream&gt;

int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 5;
    std::cout << "Factorial of " << num << " is: " << factorial(num) << std::endl;
    return 0;
}
        </pre>
        
        <h5>Example 2: Fibonacci Sequence</h5>
        <pre>
#include &lt;iostream&gt;

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int num = 6;
    std::cout << "Fibonacci of " << num << " is: " << fibonacci(num) << std::endl;
    return 0;
}
        </pre>

        <h5>Example 3: Sum of Array Elements</h5>
        <pre>
#include &lt;iostream&gt;

int sumArray(int arr[], int n) {
    if (n == 0) {
        return 0;
    } else {
        return arr[n - 1] + sumArray(arr, n - 1);
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    std::cout << "Sum of array elements is: " << sumArray(arr, n) << std::endl;
    return 0;
}
        </pre>

        <h3>Difference Between Recursion and Loops:</h3>
        
        <ul>
            <li><strong>Recursion:</strong> Involves a function calling itself. It is more natural for problems that can be divided into smaller subproblems of the same type. However, recursion can be less efficient because of the overhead associated with multiple function calls and stack usage.</li>
            <li><strong>Loops:</strong> Use a set of repeated instructions, such as `for` or `while` loops, and are generally more efficient in terms of memory and execution time. Loops are better suited for problems where the number of iterations is known and simple repetition is needed.</li>
        </ul>

        <h5>Example: Factorial using a Loop</h5>
        <pre>
#include &lt;iostream&gt;

int factorialLoop(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    int num = 5;
    std::cout << "Factorial of " << num << " using loop is: " << factorialLoop(num) << std::endl;
    return 0;
}
        </pre>

    </section>

    <footer>
        <p>Review &copy; 2024</p>
        </footer>

</body>
</html>
